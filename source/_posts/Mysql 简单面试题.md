---
title: 'Mysql 简单面试题'
date: 2020-12-31 15:01:41
tags: 
    - Mysql
    - 面试
cover: https://sailliao.oss-cn-beijing.aliyuncs.com/img/wallhaven-e7ldrr.jpg
---

## 索引的数据结构

MySQL主要有两种结构：Hash索引和B+ Tree索引，InnoDB引擎默认的是B+树

## 为什么采用B+ 树吗，这和Hash索引比较起来有什么优缺点

Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的
所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。
所以，哈希索引只适用于等值查询的场景。
哈希索引适合等值查询，但是不无法进行范围查询 
哈希索引没办法利用索引完成排序 
**哈希索引不支持多列联合索引的最左匹配规则**
如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点）

## B+ Tree的叶子节点都可以存哪些东西

InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值。

在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。
聚簇索引查询会更快，因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询
也叫做回表

## 非主键索引一定会查询多次吗

通过覆盖索引也可以只查询一次，覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 
当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 
如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：
```sql
select key2 from covering_index_sample where key1 = ‘keytest’;
```
的时候，就可以通过覆盖索引查询，无需回表。

## 联合索引、最左前缀匹配

MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。

## 索引下推

MySQL 5.6引入了索引下推优化，默认开启，使用
```sql
SET optimizer_switch = ‘index_condition_pushdown=off’;
```
可以将其关闭。官方文档中给的例子和解释如下： people表中（zipcode，lastname，firstname）构成一个索引

SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;

如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’和address LIKE ‘%Main Street%’来判断数据是否符合条件。 
如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’和address LIKE ‘%Main Street%’来判断索引是否符合条件。
如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 

有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

## 怎么判断有没有用到索引

### 查询优化器 
一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 
在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。
这个成本最低的方案就是所谓的执行计划。 
优化过程大致如下： 
1. 根据搜索条件，找出所有可能使用的索引 
2. 计算全表扫描的代价 
3. 计算使用不同索引执行查询的代价
4. 对比各种执行方案的代价，找出成本最低的那一个

## 事务隔离级别

### 事务的并发问题
1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

不可重复读的和幻读很容易混淆，**不可重复读侧重于修改**，**幻读侧重于新增或删除**。
解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

### 隔离级别

|事务隔离级别                    |脏读  |不可重复读|幻读|
|:-----------:                  |:---:|:---:     |:---:|
|读未提交（read-uncommitted）    |	是 |	是    |	是|
|不可重复读（read-committed）    |	否 |	是    |	是|
|可重复读（repeatable-read）     |	否 |否        |	是|
|串行化（serializable）	         |否   |否	      |否|

mysql默认的事务隔离级别为 **repeatable-read** 可重复读

## 总结

文章部分来源 [我以为我对Mysql索引很了解，直到我遇到了阿里的面试官](https://www.hollischuang.com/archives/3818)

其实都是很简单的初中级面试题，后面会慢慢多补充
