---
title: 恋上数据结构-三-：链表
date: 2021-01-18 16:44:52
tags: 恋上数据结构
cover: https://img9.51tietu.net/pic/2019-091404/v4vqwi4u5kvv4vqwi4u5kv.jpg
mathjax: true
---

上节中写了个简单的动态数组，动态数组有个明显的缺点
**可能会造成内存空间的大量浪费**
所以有没有一种东西，用多少申请多少，所以链表就出现了

> 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的

![](1.png)

## 接口设计

链表的接口设计和数组的接口设计其实是差不多的,只是在个别地方有些小区别



### clear

清空元素时，在设置 size 为 0 的同事，我们将头结点置为null就行，这样没有引用指向 next 及 next以后的元素，垃圾回收器会自动回收的

### add(int index, E element)

例如要在 index 2 这个位置添加元素 E, 那么应该断开 1 和 2 这个链接，让 1 的 next 指向新加元素 E, E 的 next 指向 之前的 2，然后再 size++

另外注意添加原素 index 为0的时候，也就是头结点

## 练习

一些leetcode上的题

### 删除节点

> 输入 head = [4, 5, 1, 9], node = 1
> 输出 [4, 5, 9]
> 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
> https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

给定的方法是:
```java
public void deleteNode(ListNode node) {
    
}
```
也就是说，传给我哪个节点，就删除哪个节点，但是我们在之前做节点删除的时候，是需要获取到要删除的节点的前一个节点，这样把前一个节点的 next 指向 要删除的节点的下一个节点，这样就完成了删除。
但是这里没有前一个节点。
思考：要删除这个节点，让这个节点消失就行了，可不可以用 next 节点的来覆盖要删除的节点，对吧。
```java
public void deleteNode(ListNode node) {
    ListNode next = node.next;
    node.val = next.val;
    node.next = next.next;
}
```

### 链表反转

> 输入 1->2->3->4->5->NULL
> 输出 5->4->3->2->1->NULL
> 解释：使用递归和迭代两种方式
> https://leetcode-cn.com/problems/reverse-linked-list/

正常情况下，我们一个链表应该是这样的

![](2.png)

如果我们先不考虑5个，我们考虑4个，例如 head.next 也就是从 2、3、4、5，那么 2、3、4、5 完成反转后应该如下图所示

![](3.png)

这个时候，**1 的 next 还是指向 2 的**，就下来要做的应该做的就是把 2 的 next 指向 1 ，把 1 的 next 指向 null, 要注意这个先后顺序

![](4.png)

同理，我们在 反转 2、3、4、5 的时候先反转 3、4、5，这样就是递归的思路，同时需要考虑边界条件

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode tmp = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return tmp;
}
```

不用递归用迭代的方式，我们先定一个新的节点，让新节点指向 head ，让 head 的 next 指向空

![](5.png)

![](6.png)

这样 2 这个节点就成为了 head 节点, 接下来我们先让 2 的 next 指向 1

![](7.png)

再把新节点的 next 指向 2，这样 3 就成为的 head

![](8.png)

调整下位置

![](9.png)

接下来要干啥是不是很清晰了，再让新的 head 3 指向 2，让新加节点指向 3

```java
public ListNode reverseList(ListNode head) {
    ListNode tmp = new ListNode(0);
    while (head != null){
        // 先获取到下个节点
        ListNode next = head.next;
        // 让 head 节点 “干净”
        head.next = null;
        // 重新赋值,所以上面的哪一行代码可以去掉了
        head.next = tmp.next;
        // 让 tmp 的头节点重新指向新来的head
        tmp.next = head;
        // 让原来的head去除头节点
        head = next;
    }
    return tmp.next;
}
```

### 环形链表

> 给定一个链表，判断链表中是否有环。
> https://leetcode-cn.com/problems/linked-list-cycle/

例如这种

![](10.png)

![](11.png)

这种算有环

解法：**快慢指针**

![](12.png)

我们定义一个慢指针，一个快指针，慢指针每次**前进**一个 next (.next)，慢指针每次**前进**两个 next (.next.next)，如果链表里面有环，那么两个指针最终肯定会相遇，如果没有环，那么快指针一定会在末尾停下来，并且 next 是空。
需要注意的是考虑边界

```java
public static boolean hasCycle(ListNode head) {
    if(head == null || head.next == null){
        return false;
    }

    // 开始不都指向 head，是为了好判断
    ListNode slow = head;
    ListNode fast = head.next;

    while (true){
        if (slow == fast) {
            return true;
        }
        if (fast == null || fast.next == null || fast.next.next == null ) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
}
```
这个是自己写的蠢办法，时间和空间都浪费很多
```java
public static boolean hasCycle(ListNode head) {
    if(head == null || head.next == null){
        return false;
    }
    List<ListNode> list = new ArrayList<>();
    list.contains(head);
    while (true){
        head = head.next;
        if (list.contains(head)) {
            return true;
        }
        if (head == null) {
            return false;
        }
        list.add(head);
    }
}
```
下面是一些骚操作
```python
# 相同数据出现就是有重复的，不过严格上有bug
class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        while head:
            if head.val == 'bjfuvth':
                return True
            else:
                head.val = 'bjfuvth'
            head = head.next
        return False
```

```java
// 测试样例最多的有8029个元素，一直获取就行，要么有环，要么最后一个节点的 next 为空
public class Solution {
    public boolean hasCycle(ListNode head) {
        int count=8029;
        
        while(head!=null&&count>0){
            head=head.next;
            count--;
        }
        if(head==null)
            return false;
        return true;
    }
}
```

### 移除链表元素

> 删除链表中等于给定值 val 的所有节点。
> 输入: 1->2->6->3->4->5->6, val = 6
> 输出: 1->2->3->4->5
> https://leetcode-cn.com/problems/remove-linked-list-elements/

类似的移除元素，都是一种思路，之前介绍过的，如果当前的节点的值与传入的 val 相等，可以让 next 节点覆盖本节点，但是想想，如果我要删除的元素是最后一个元素，这个时候我是没有前一个节点的，我自己没办法把自己删掉。

```java
// 第一种方式
public ListNode removeElements(ListNode head, int val) {
    // 有个头结点
    ListNode re = new ListNode(0);
    // 头结点指向head，这样遍历head的时候就没问题了
    re.next = head;
    // 声明前一个节点
    ListNode pre = re;
    while (head != null) {
        if (head.val == val) {
            // 如果值相等，让前一个节点的next指向本节点的下一个节点，相当于把自己剔除出去了
            pre.next = head.next;
        } else {
            // 前一个节点成为本节点
            pre = head;
        }
        // 当前节点转换到下一个节点
        head = head.next;
    }
    return re.next;
}
```


### 删除排序链表中的重复元素

> 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
> 输入: 1->1->2 输出: 1->2
> 输入: 1->1->2->3->3 输出: 1->2->3
> https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/

因为是删除重复的元素所以很容易就想到找个东西存一下，例如 List 如果list里面出现过了就进行删除操作，删除的想法和之前是一样的，用个 pre 节点
```java
public static ListNode deleteDuplicates(ListNode head) {
    ListNode re = new ListNode(0);
    re.next = head;

    ListNode pre = re;

    List<Integer> exist = new ArrayList<>();

    while (head != null){
        if (exist.contains(head.val)) {
            pre.next = head.next;
        }else{
            pre = head;
            exist.add(head.val);
        }
        head = head.next;
    }
    return re.next;
}
```
但是这种效率很不好，另外还多个 List 变量，空间也会变多，仔细读题后发现是 **给定一个排序链表** 链表是排好顺序的，所以我在当前节点的时候，判断下个节点，如果两个值一样，用下个节点来覆盖当前节点也能做到
```java
public static ListNode deleteDuplicates(ListNode head) {
    ListNode re = new ListNode(0);
    re.next = head;
    while (head != null && head.next != null) {
        if (head.val == head.next.val) {
            head.next = head.next.next;
            continue;
        }
        head = head.next;
    }
    return re.next;
}
```

### 链表的中间结点

> 给定一个头结点为 head的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
> 输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5])
> 输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6])
> https://leetcode-cn.com/problems/middle-of-the-linked-list

思考：相当于要把一个链表从中间破开，我首先要知道从哪儿破开对吧，肯定需要知道整个长度，
```java
public ListNode middleNode(ListNode head) {
    Map<Integer, ListNode> map = new HashMap<>();
    int index = 0;
    while (head != null) {
        ListNode tmp = head;
        map.put(index, tmp);
        index++;
        head = head.next;
    }
    return map.get(index / 2);
}
```
这种方式其实不好，不优雅，我们之前在判断环行链表的时候，慢指针一次性走一步，快指针一次性走两步，那么当快指针走到末尾的时候，慢指针是不是刚好走到一半呢，是的，因为快指针的**速度**是慢指针的两倍

```java
public ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head.next;

    while (true){
        if (fast == null) {
            return slow;
        }
        if (fast.next == null) {
            return slow.next;
        }
        slow = slow.next;
        fast = fast.next.next;
    }

}
```

在边界上要初一处理，如果经过一次循环，fast.next 为空，但是 fast 不为空，返回的 应该是 slow.next

## 虚拟头结点

有时候为了让代码更加精简，统一所有节点的处理逻辑，可以在最前面增加一个虚拟的头结点（不存储数据）

![](13.png)

例如我添加一个元素，在 1 这个位置添加的时候，我是需要找到 0 这个位置，但是如果我直接在 0 这个位置进行添加，0 没有前面的元素，所以需要对0这个index进行特殊处理。

所以增加 虚拟头节点 就能统一处理很多事情了

## 双向链表

之前我们学的都是单向链表，因为 前一个节点指向后一个节点。双向链表，顾名思义，就是后一个节点也会指向前一个节点，双向链表可以提升链表的综合性能。

![](14.png)

因为有 first 节点和 last 节点，所以在获取摸个元素的时候可以考虑从不同的方向去遍历。