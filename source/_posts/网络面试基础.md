---
title: 网络面试基础
date: 2021-04-30 15:39:32
tags: 面试
cover: https://sailliao.oss-cn-beijing.aliyuncs.com/img/wallhaven-e7l9dr.jpg
---

# Https如何保证数据安全

http 没有对数据加密，都是明文传输

## 对称加密

发送数据的时候，服务器先生成一把密钥，把密钥传给客户端。之后服务器发送数据前用这个密钥进行加密，再把数据发送给客户端，客户端拿到数据后用这个密钥进行解密.

* 但是密钥的传递是明文的，容易被截取，被截取后加密就没意义

## 非对称加密 RSA

* 加密用的一个密钥，解密用的另外一个密钥。
* 用公钥加密的数据，只有对应的私钥才能解密；用私钥加密的数据，只有对应的公钥才能解密。
* 公钥是公开的

这种方式加密的时候比较慢，所以可以用非对称加密的方式传输对称加密的密钥，

1. 服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，
2. 然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全着得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。

非对称加密也不是传输安全的,例如，在服务器用明文的方式给客户端发送公钥的时候被别人截取和替换掉了，把非法公钥传给了客户端，然后客户端生成的对称加密的私钥，用公钥加密传给服务器的时候又被截取了，这样中间人就得到的全部的关键东西。发生问题的关键在于明文传递的公钥，客户端不知道是不是服务器的。所以有了 **数字证书**

我们需要找到一个拥有公信力、大家都认可的**认证中心(CA)**。

服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。

为了防止信息摘要被人调换，服务器还会用CA提供的私钥对信息摘要进行加密来形成数字签名。
最后还会把原来没Hash算法之前的个人信息以及公钥 和 数字签名合并在一起，形成数字证书。、
当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。
服务器一开始就向认证中心申请了这些证书了(有没有看过没有证书的网站在地址栏会被标出警告？)，而客户端是，也会内置这些证书。

# 三次握手与四次挥手

老生常谈的东西，也记录一下

## 三次握手
![](1.png)

### 过程

开始客户端和服务器都处于CLOSED状态，然后服务端开始监听某个端口，进入LISTEN状态

* 第一次握手(SYN=1, seq=x)，发送完毕后，客户端进入 SYN_SEND 状态
* 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端进入 SYN_RCVD 状态。
* 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时,也进入 ESTABLISHED 状态，TCP 握手，即可以开始数据传输。

## 四次挥手

![](2.png)

### 过程

* 第一次挥手(FIN=1，seq=u)，发送完毕后，客户端进入FIN_WAIT_1 状态
* 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态
* 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入LAST_ACK 状态，等待来自客户端的最后一个ACK。
* 第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个* 最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

